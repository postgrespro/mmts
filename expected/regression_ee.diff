diff ../../../src/test/regress/expected/create_table.out ../tmp_check/regress_outdir/results/create_table.out
--- ../../../src/test/regress/expected/create_table.out	CENSORED
+++ ../tmp_check/regress_outdir/results/create_table.out	CENSORED
@@ -263,17 +263,17 @@
 DROP TABLE as_select1;
 PREPARE select1 AS SELECT 1 as a;
 CREATE TABLE as_select1 AS EXECUTE select1;
+ERROR:  [MTM] failed to prepare transaction at peer node
 CREATE TABLE as_select1 AS EXECUTE select1;
-ERROR:  relation "as_select1" already exists
+ERROR:  [MTM] failed to prepare transaction at peer node
 SELECT * FROM as_select1;
- a 
----
- 1
-(1 row)
-
+ERROR:  relation "as_select1" does not exist
+LINE 1: SELECT * FROM as_select1;
+                      ^
 CREATE TABLE IF NOT EXISTS as_select1 AS EXECUTE select1;
-NOTICE:  relation "as_select1" already exists, skipping
+ERROR:  [MTM] failed to prepare transaction at peer node
 DROP TABLE as_select1;
+ERROR:  table "as_select1" does not exist
 DEALLOCATE select1;
 -- create an extra wide table to test for issues related to that
 -- (temporarily hide query, to avoid the long CREATE TABLE stmt)
diff ../../../src/test/regress/expected/create_index.out ../tmp_check/regress_outdir/results/create_index.out
--- ../../../src/test/regress/expected/create_index.out	CENSORED
+++ ../tmp_check/regress_outdir/results/create_index.out	CENSORED
@@ -1398,31 +1398,33 @@
 CREATE TABLE concur_heap (f1 text, f2 text);
 -- empty table
 CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
-NOTICE:  relation "concur_index1" already exists, skipping
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 INSERT INTO concur_heap VALUES  ('a','b');
 INSERT INTO concur_heap VALUES  ('b','b');
 -- unique index
 CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
-NOTICE:  relation "concur_index2" already exists, skipping
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 -- check if constraint is set up properly to be enforced
 INSERT INTO concur_heap VALUES ('b','x');
-ERROR:  duplicate key value violates unique constraint "concur_index2"
-DETAIL:  Key (f1)=(b) already exists.
 -- check if constraint is enforced properly at build time
 CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
-ERROR:  could not create unique index "concur_index3"
-DETAIL:  Key (f2)=(b) is duplicated.
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 -- test that expression indexes and partial indexes work concurrently
 CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 -- here we also check that you can default the index name
 CREATE INDEX CONCURRENTLY on concur_heap((f2||f1));
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 -- You can't do a concurrent index build in a transaction
 BEGIN;
 CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
-ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 COMMIT;
 -- test where predicate is able to do a transactional update during
 -- a concurrent build before switching pg_index state flags.
@@ -1434,7 +1436,9 @@
 END; $$;
 CREATE INDEX CONCURRENTLY concur_index8 ON concur_heap (f1)
   WHERE predicate_stable();
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 DROP INDEX concur_index8;
+ERROR:  index "concur_index8" does not exist
 DROP FUNCTION predicate_stable();
 -- But you can do a regular index build in a transaction
 BEGIN;
@@ -1443,8 +1447,6 @@
 -- Failed builds are left invalid by VACUUM FULL, fixed by REINDEX
 VACUUM FULL concur_heap;
 REINDEX TABLE concur_heap;
-ERROR:  could not create unique index "concur_index3"
-DETAIL:  Key (f2)=(b) is duplicated.
 DELETE FROM concur_heap WHERE f1 = 'b';
 VACUUM FULL concur_heap;
 \d concur_heap
@@ -1454,12 +1456,6 @@
  f1     | text |           |          | 
  f2     | text |           |          | 
 Indexes:
-    "concur_heap_expr_idx" btree ((f2 || f1))
-    "concur_index1" btree (f2, f1)
-    "concur_index2" UNIQUE, btree (f1)
-    "concur_index3" UNIQUE, btree (f2) INVALID
-    "concur_index4" btree (f2) WHERE f1 = 'a'::text
-    "concur_index5" btree (f2) WHERE f1 = 'x'::text
     "std_index" btree (f2)
 
 REINDEX TABLE concur_heap;
@@ -1470,12 +1466,6 @@
  f1     | text |           |          | 
  f2     | text |           |          | 
 Indexes:
-    "concur_heap_expr_idx" btree ((f2 || f1))
-    "concur_index1" btree (f2, f1)
-    "concur_index2" UNIQUE, btree (f1)
-    "concur_index3" UNIQUE, btree (f2)
-    "concur_index4" btree (f2) WHERE f1 = 'a'::text
-    "concur_index5" btree (f2) WHERE f1 = 'x'::text
     "std_index" btree (f2)
 
 -- Temporary tables with concurrent builds and on-commit actions
@@ -1485,7 +1475,9 @@
   ON COMMIT PRESERVE ROWS;
 INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
 CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 DROP INDEX CONCURRENTLY concur_temp_ind;
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 DROP TABLE concur_temp;
 -- ON COMMIT DROP
 BEGIN;
@@ -1494,34 +1486,42 @@
 INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
 -- Fails when running in a transaction.
 CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
-ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 COMMIT;
 -- ON COMMIT DELETE ROWS
 CREATE TEMP TABLE concur_temp (f1 int, f2 text)
   ON COMMIT DELETE ROWS;
 INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
 CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 DROP INDEX CONCURRENTLY concur_temp_ind;
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 DROP TABLE concur_temp;
 --
 -- Try some concurrent index drops
 --
 DROP INDEX CONCURRENTLY "concur_index2";				-- works
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 DROP INDEX CONCURRENTLY IF EXISTS "concur_index2";		-- notice
-NOTICE:  index "concur_index2" does not exist, skipping
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 -- failures
 DROP INDEX CONCURRENTLY "concur_index2", "concur_index3";
-ERROR:  DROP INDEX CONCURRENTLY does not support dropping multiple objects
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 BEGIN;
 DROP INDEX CONCURRENTLY "concur_index5";
-ERROR:  DROP INDEX CONCURRENTLY cannot run inside a transaction block
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 ROLLBACK;
 -- successes
 DROP INDEX CONCURRENTLY IF EXISTS "concur_index3";
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 DROP INDEX CONCURRENTLY "concur_index4";
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 DROP INDEX CONCURRENTLY "concur_index5";
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 DROP INDEX CONCURRENTLY "concur_index1";
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 DROP INDEX CONCURRENTLY "concur_heap_expr_idx";
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 \d concur_heap
            Table "public.concur_heap"
  Column | Type | Collation | Nullable | Default 
@@ -2610,46 +2610,38 @@
 INSERT INTO concur_reindex_tab4 VALUES (1), (1), (2);
 -- This trick creates an invalid index.
 CREATE UNIQUE INDEX CONCURRENTLY concur_reindex_ind5 ON concur_reindex_tab4 (c1);
-ERROR:  could not create unique index "concur_reindex_ind5"
-DETAIL:  Key (c1)=(1) is duplicated.
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 -- Reindexing concurrently this index fails with the same failure.
 -- The extra index created is itself invalid, and can be dropped.
 REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
-ERROR:  could not create unique index "concur_reindex_ind5_ccnew"
-DETAIL:  Key (c1)=(1) is duplicated.
+ERROR:  relation "concur_reindex_ind5" does not exist
 \d concur_reindex_tab4
         Table "public.concur_reindex_tab4"
  Column |  Type   | Collation | Nullable | Default 
 --------+---------+-----------+----------+---------
  c1     | integer |           |          | 
-Indexes:
-    "concur_reindex_ind5" UNIQUE, btree (c1) INVALID
-    "concur_reindex_ind5_ccnew" UNIQUE, btree (c1) INVALID
 
 DROP INDEX concur_reindex_ind5_ccnew;
+ERROR:  index "concur_reindex_ind5_ccnew" does not exist
 -- This makes the previous failure go away, so the index can become valid.
 DELETE FROM concur_reindex_tab4 WHERE c1 = 1;
 -- The invalid index is not processed when running REINDEX TABLE.
 REINDEX TABLE CONCURRENTLY concur_reindex_tab4;
-WARNING:  cannot reindex invalid index "public.concur_reindex_ind5" concurrently, skipping
 NOTICE:  table "concur_reindex_tab4" has no indexes that can be reindexed concurrently
 \d concur_reindex_tab4
         Table "public.concur_reindex_tab4"
  Column |  Type   | Collation | Nullable | Default 
 --------+---------+-----------+----------+---------
  c1     | integer |           |          | 
-Indexes:
-    "concur_reindex_ind5" UNIQUE, btree (c1) INVALID
 
 -- But it is fixed with REINDEX INDEX.
 REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
+ERROR:  relation "concur_reindex_ind5" does not exist
 \d concur_reindex_tab4
         Table "public.concur_reindex_tab4"
  Column |  Type   | Collation | Nullable | Default 
 --------+---------+-----------+----------+---------
  c1     | integer |           |          | 
-Indexes:
-    "concur_reindex_ind5" UNIQUE, btree (c1)
 
 DROP TABLE concur_reindex_tab4;
 -- Check handling of indexes with expressions and predicates.  The
diff ../../../src/test/regress/expected/index_including.out ../tmp_check/regress_outdir/results/index_including.out
--- ../../../src/test/regress/expected/index_including.out	CENSORED
+++ ../tmp_check/regress_outdir/results/index_including.out	CENSORED
@@ -310,12 +310,12 @@
 CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box, UNIQUE(c1, c2) INCLUDE(c3,c4));
 INSERT INTO tbl SELECT x, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,1000) AS x;
 CREATE UNIQUE INDEX CONCURRENTLY on tbl (c1, c2) INCLUDE (c3, c4);
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl' ORDER BY indexname;
                                           indexdef                                           
 ---------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX tbl_c1_c2_c3_c4_idx ON public.tbl USING btree (c1, c2) INCLUDE (c3, c4)
  CREATE UNIQUE INDEX tbl_c1_c2_c3_c4_key ON public.tbl USING btree (c1, c2) INCLUDE (c3, c4)
-(2 rows)
+(1 row)
 
 DROP TABLE tbl;
 /*
diff ../../../src/test/regress/expected/index_including_gist.out ../tmp_check/regress_outdir/results/index_including_gist.out
--- ../../../src/test/regress/expected/index_including_gist.out	CENSORED
+++ ../tmp_check/regress_outdir/results/index_including_gist.out	CENSORED
@@ -74,11 +74,11 @@
 CREATE TABLE tbl_gist (c1 int, c2 int, c3 int, c4 box);
 INSERT INTO tbl_gist SELECT x, 2*x, 3*x, box(point(x,x+1),point(2*x,2*x+1)) FROM generate_series(1,10) AS x;
 CREATE INDEX CONCURRENTLY tbl_gist_idx ON tbl_gist using gist (c4) INCLUDE (c1,c2,c3);
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl_gist' ORDER BY indexname;
-                                     indexdef                                      
------------------------------------------------------------------------------------
- CREATE INDEX tbl_gist_idx ON public.tbl_gist USING gist (c4) INCLUDE (c1, c2, c3)
-(1 row)
+ indexdef 
+----------
+(0 rows)
 
 DROP TABLE tbl_gist;
 /*
diff ../../../src/test/regress/expected/sanity_check.out ../tmp_check/regress_outdir/results/sanity_check.out
--- ../../../src/test/regress/expected/sanity_check.out	CENSORED
+++ ../tmp_check/regress_outdir/results/sanity_check.out	CENSORED
@@ -32,6 +32,8 @@
 check_tbl|f
 circle_tbl|t
 city|f
+cluster_nodes|t
+config|t
 copy_tbl|f
 d|f
 d_star|f
@@ -67,6 +69,7 @@
 jtbl|t
 kd_point_tbl|t
 line_tbl|f
+local_tables|t
 log_table|f
 lseg_tbl|f
 main_table|f
@@ -83,6 +86,7 @@
 mlparted_defd|f
 money_data|f
 mytable|t
+nodes_init_done|t
 num_data|f
 num_exp_add|t
 num_exp_div|t
@@ -187,6 +191,7 @@
 sql_sizing|f
 stud_emp|f
 student|f
+syncpoints|t
 tab_core_types|f
 tableam_parted_a_heap2|f
 tableam_parted_b_heap2|f
diff ../../../src/test/regress/expected/select_into.out ../tmp_check/regress_outdir/results/select_into.out
--- ../../../src/test/regress/expected/select_into.out	CENSORED
+++ ../tmp_check/regress_outdir/results/select_into.out	CENSORED
@@ -50,27 +50,19 @@
 PREPARE data_sel AS SELECT generate_series(1,3);
 CREATE TABLE selinto_schema.tbl_withdata3 (a) AS
   EXECUTE data_sel WITH DATA;
+ERROR:  [MTM] failed to prepare transaction at peer node
 EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
   CREATE TABLE selinto_schema.tbl_withdata4 (a) AS
   EXECUTE data_sel WITH DATA;
-              QUERY PLAN              
---------------------------------------
- ProjectSet (actual rows=3 loops=1)
-   ->  Result (actual rows=1 loops=1)
-(2 rows)
-
+ERROR:  [MTM] failed to prepare transaction at peer node
 -- EXECUTE and WITH NO DATA, passes.
 CREATE TABLE selinto_schema.tbl_nodata3 (a) AS
   EXECUTE data_sel WITH NO DATA;
+ERROR:  [MTM] failed to prepare transaction at peer node
 EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
   CREATE TABLE selinto_schema.tbl_nodata4 (a) AS
   EXECUTE data_sel WITH NO DATA;
-          QUERY PLAN           
--------------------------------
- ProjectSet (never executed)
-   ->  Result (never executed)
-(2 rows)
-
+ERROR:  [MTM] failed to prepare transaction at peer node
 RESET SESSION AUTHORIZATION;
 ALTER DEFAULT PRIVILEGES FOR ROLE regress_selinto_user
 	  GRANT INSERT ON TABLES TO regress_selinto_user;
@@ -78,15 +70,11 @@
 RESET SESSION AUTHORIZATION;
 DEALLOCATE data_sel;
 DROP SCHEMA selinto_schema CASCADE;
-NOTICE:  drop cascades to 8 other objects
+NOTICE:  drop cascades to 4 other objects
 DETAIL:  drop cascades to table selinto_schema.tbl_withdata1
 drop cascades to table selinto_schema.tbl_withdata2
 drop cascades to table selinto_schema.tbl_nodata1
 drop cascades to table selinto_schema.tbl_nodata2
-drop cascades to table selinto_schema.tbl_withdata3
-drop cascades to table selinto_schema.tbl_withdata4
-drop cascades to table selinto_schema.tbl_nodata3
-drop cascades to table selinto_schema.tbl_nodata4
 DROP USER regress_selinto_user;
 -- Tests for WITH NO DATA and column name consistency
 CREATE TABLE ctas_base (i int, j int);
diff ../../../src/test/regress/expected/transactions.out ../tmp_check/regress_outdir/results/transactions.out
--- ../../../src/test/regress/expected/transactions.out	CENSORED
+++ ../tmp_check/regress_outdir/results/transactions.out	CENSORED
@@ -685,50 +685,38 @@
 INSERT INTO abc VALUES (1);
 INSERT INTO abc VALUES (2);
 COMMIT AND CHAIN;  -- TBLOCK_END
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 SHOW transaction_isolation;
- transaction_isolation 
------------------------
- repeatable read
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SHOW transaction_read_only;
- transaction_read_only 
------------------------
- off
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SHOW transaction_deferrable;
- transaction_deferrable 
-------------------------
- on
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 INSERT INTO abc VALUES ('error');
-ERROR:  invalid input syntax for type integer: "error"
-LINE 1: INSERT INTO abc VALUES ('error');
-                                ^
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 INSERT INTO abc VALUES (3);  -- check it's really aborted
 ERROR:  current transaction is aborted, commands ignored until end of transaction block
 COMMIT AND CHAIN;  -- TBLOCK_ABORT_END
 SHOW transaction_isolation;
  transaction_isolation 
 -----------------------
- repeatable read
+ read committed
 (1 row)
 
 SHOW transaction_read_only;
  transaction_read_only 
 -----------------------
- off
+ on
 (1 row)
 
 SHOW transaction_deferrable;
  transaction_deferrable 
 ------------------------
- on
+ off
 (1 row)
 
 INSERT INTO abc VALUES (4);
+ERROR:  cannot execute INSERT in a read-only transaction
 COMMIT;
 START TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ WRITE, DEFERRABLE;
 SHOW transaction_isolation;
@@ -796,24 +784,13 @@
 
 SAVEPOINT x;
 COMMIT AND CHAIN;  -- TBLOCK_SUBCOMMIT
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 SHOW transaction_isolation;
- transaction_isolation 
------------------------
- repeatable read
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SHOW transaction_read_only;
- transaction_read_only 
------------------------
- off
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SHOW transaction_deferrable;
- transaction_deferrable 
-------------------------
- on
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 COMMIT;
 -- different mix of options just for fun
 START TRANSACTION ISOLATION LEVEL SERIALIZABLE, READ WRITE, NOT DEFERRABLE;
@@ -881,17 +858,14 @@
 ROLLBACK;
 -- not allowed outside a transaction block
 COMMIT AND CHAIN;  -- error
-ERROR:  COMMIT AND CHAIN can only be used in transaction blocks
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 ROLLBACK AND CHAIN;  -- error
 ERROR:  ROLLBACK AND CHAIN can only be used in transaction blocks
 SELECT * FROM abc ORDER BY 1;
  a 
 ---
- 1
- 2
- 4
  5
-(4 rows)
+(1 row)
 
 RESET default_transaction_read_only;
 DROP TABLE abc;
@@ -981,7 +955,7 @@
 SELECT 1\; BEGIN\; SAVEPOINT sp\; ROLLBACK TO SAVEPOINT sp\; COMMIT;
 -- Tests for AND CHAIN in implicit transaction blocks
 SET TRANSACTION READ ONLY\; COMMIT AND CHAIN;  -- error
-ERROR:  COMMIT AND CHAIN can only be used in transaction blocks
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 SHOW transaction_read_only;
  transaction_read_only 
 -----------------------
@@ -1000,23 +974,20 @@
 -- COMMIT/ROLLBACK + COMMIT/ROLLBACK AND CHAIN
 INSERT INTO abc VALUES (7)\; COMMIT\; INSERT INTO abc VALUES (8)\; COMMIT AND CHAIN;  -- 7 commit, 8 error
 WARNING:  there is no transaction in progress
-ERROR:  COMMIT AND CHAIN can only be used in transaction blocks
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 INSERT INTO abc VALUES (9)\; ROLLBACK\; INSERT INTO abc VALUES (10)\; ROLLBACK AND CHAIN;  -- 9 rollback, 10 error
 WARNING:  there is no transaction in progress
 ERROR:  ROLLBACK AND CHAIN can only be used in transaction blocks
 -- COMMIT/ROLLBACK AND CHAIN + COMMIT/ROLLBACK
 INSERT INTO abc VALUES (11)\; COMMIT AND CHAIN\; INSERT INTO abc VALUES (12)\; COMMIT;  -- 11 error, 12 not reached
-ERROR:  COMMIT AND CHAIN can only be used in transaction blocks
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 INSERT INTO abc VALUES (13)\; ROLLBACK AND CHAIN\; INSERT INTO abc VALUES (14)\; ROLLBACK;  -- 13 error, 14 not reached
 ERROR:  ROLLBACK AND CHAIN can only be used in transaction blocks
 -- START TRANSACTION + COMMIT/ROLLBACK AND CHAIN
 START TRANSACTION ISOLATION LEVEL REPEATABLE READ\; INSERT INTO abc VALUES (15)\; COMMIT AND CHAIN;  -- 15 ok
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 SHOW transaction_isolation;  -- transaction is active at this point
- transaction_isolation 
------------------------
- repeatable read
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 COMMIT;
 START TRANSACTION ISOLATION LEVEL REPEATABLE READ\; INSERT INTO abc VALUES (16)\; ROLLBACK AND CHAIN;  -- 16 ok
 SHOW transaction_isolation;  -- transaction is active at this point
@@ -1029,7 +1000,7 @@
 SET default_transaction_isolation = 'read committed';
 -- START TRANSACTION + COMMIT/ROLLBACK + COMMIT/ROLLBACK AND CHAIN
 START TRANSACTION ISOLATION LEVEL REPEATABLE READ\; INSERT INTO abc VALUES (17)\; COMMIT\; INSERT INTO abc VALUES (18)\; COMMIT AND CHAIN;  -- 17 commit, 18 error
-ERROR:  COMMIT AND CHAIN can only be used in transaction blocks
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 SHOW transaction_isolation;  -- out of transaction block
  transaction_isolation 
 -----------------------
@@ -1049,9 +1020,8 @@
  a  
 ----
   7
- 15
  17
-(3 rows)
+(2 rows)
 
 DROP TABLE abc;
 -- Test for successful cleanup of an aborted transaction at session exit.
diff ../../../src/test/regress/expected/brin.out ../tmp_check/regress_outdir/results/brin.out
--- ../../../src/test/regress/expected/brin.out	CENSORED
+++ ../tmp_check/regress_outdir/results/brin.out	CENSORED
@@ -539,7 +539,9 @@
 -- vacuum actually removes the TOAST rows. Creating an index concurrently
 -- is a one way to achieve that, because it does exactly such wait.
 CREATE INDEX CONCURRENTLY brin_test_temp_idx ON brintest_3(a);
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 DROP INDEX brin_test_temp_idx;
+ERROR:  index "brin_test_temp_idx" does not exist
 -- vacuum the table, to discard TOAST data
 VACUUM brintest_3;
 -- retry insert with a different random-looking (but deterministic) value
diff ../../../src/test/regress/expected/privileges.out ../tmp_check/regress_outdir/results/privileges.out
--- ../../../src/test/regress/expected/privileges.out	CENSORED
+++ ../tmp_check/regress_outdir/results/privileges.out	CENSORED
@@ -1493,11 +1493,16 @@
 -- Do the same concurrently
 CREATE INDEX CONCURRENTLY sro_idx ON sro_tab ((sro_ifun(a) + sro_ifun(0)))
 	WHERE sro_ifun(a + 10) > sro_ifun(10);
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 -- REINDEX
 REINDEX TABLE sro_tab;
+NOTICE:  table "sro_tab" has no indexes to reindex
 REINDEX INDEX sro_idx;
+ERROR:  relation "sro_idx" does not exist
 REINDEX TABLE CONCURRENTLY sro_tab;
+NOTICE:  table "sro_tab" has no indexes that can be reindexed concurrently
 DROP INDEX sro_idx;
+ERROR:  index "sro_idx" does not exist
 -- CLUSTER
 CREATE INDEX sro_cluster_idx ON sro_tab ((sro_ifun(a) + sro_ifun(0)));
 CLUSTER sro_tab USING sro_cluster_idx;
diff ../../../src/test/regress/expected/atx2.out ../tmp_check/regress_outdir/results/atx2.out
--- ../../../src/test/regress/expected/atx2.out	CENSORED
+++ ../tmp_check/regress_outdir/results/atx2.out	CENSORED
@@ -287,17 +287,14 @@
   return 1;
 end$$;
 select atx_lo_test10(:my_loid);
+NOTICE:  other exception 42703, [MTM] failed to prepare transaction at peer node
  atx_lo_test10 
 ---------------
              1
 (1 row)
 
 select lo_unlink(:my_loid);
- lo_unlink 
------------
-         1
-(1 row)
-
+ERROR:  [MTM] failed to prepare transaction at peer node
 -- put some initial data
 select lo_creat(-1) as my_loid \gset
 select lo_put( :my_loid, 0, 'lo test' );
@@ -356,6 +353,7 @@
     declare c2 cursor with hold for select count_tt1_v(), count_tt1_s();
     insert into atx_tt1 values(2);
   commit;
+ERROR:  cannot PREPARE a transaction that has created a cursor WITH HOLD
 commit;
 begin;
   begin autonomous;
@@ -371,6 +369,7 @@
 drop function count_tt1_s();
 drop table if exists atx_tt1;
 close c2;
+ERROR:  cursor "c2" does not exist
 -- 13
 create table atx_13_t(i int);
 begin;
@@ -490,9 +489,7 @@
 		insert into atx_tt2 values(1);
 		declare c2 cursor with hold for select error_function();
 	commit;
-NOTICE:  other exception 22012, division by zero
-ERROR:  control reached end of function without RETURN
-CONTEXT:  PL/pgSQL function error_function()
+ERROR:  cannot PREPARE a transaction that has created a cursor WITH HOLD
 commit;
 drop function if exists error_function();
 drop table if exists atx_tt2;
@@ -582,6 +579,7 @@
 RESET client_min_messages;
 create database regression_atx_test_database;
 ALTER DATABASE "regression_atx_test_database" SET lc_messages TO 'C';
+ERROR:  [MTM] failed to prepare transaction at peer node
 \c regression_atx_test_database
 create table atx_test as select 1 as id;
 begin;
diff ../../../src/test/regress/expected/atx3.out ../tmp_check/regress_outdir/results/atx3.out
--- ../../../src/test/regress/expected/atx3.out	CENSORED
+++ ../tmp_check/regress_outdir/results/atx3.out	CENSORED
@@ -115,10 +115,7 @@
 NOTICE:  function atx_test_30_one() does not exist, skipping
 NOTICE:  function atx_test_30_one() does not exist, skipping
 NOTICE:  function atx_test_30_one() does not exist, skipping
- x 
----
-(0 rows)
-
+ERROR:  cannot PREPARE a transaction that has exported snapshots
 SET client_min_messages = 'warning';
 DROP FUNCTION IF EXISTS atx_test_30_one();
 DROP FUNCTION IF EXISTS atx_test_30_two();
@@ -383,50 +380,38 @@
 INSERT INTO abc VALUES (1);
 INSERT INTO abc VALUES (2);
 COMMIT AND CHAIN;  -- TBLOCK_END
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 SHOW transaction_isolation;
- transaction_isolation 
------------------------
- repeatable read
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SHOW transaction_read_only;
- transaction_read_only 
------------------------
- off
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SHOW transaction_deferrable;
- transaction_deferrable 
-------------------------
- on
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 INSERT INTO abc VALUES ('error');
-ERROR:  invalid input syntax for type integer: "error"
-LINE 1: INSERT INTO abc VALUES ('error');
-                                ^
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 INSERT INTO abc VALUES (3);  -- check it's really aborted
 ERROR:  current transaction is aborted, commands ignored until end of transaction block
 COMMIT AND CHAIN;  -- TBLOCK_ABORT_END
 SHOW transaction_isolation;
  transaction_isolation 
 -----------------------
- repeatable read
+ read committed
 (1 row)
 
 SHOW transaction_read_only;
  transaction_read_only 
 -----------------------
- off
+ on
 (1 row)
 
 SHOW transaction_deferrable;
  transaction_deferrable 
 ------------------------
- on
+ off
 (1 row)
 
 INSERT INTO abc VALUES (4);
+ERROR:  cannot execute INSERT in a read-only transaction
 COMMIT;
 ROLLBACK;
 BEGIN;
@@ -498,24 +483,13 @@
 
 SAVEPOINT x;
 COMMIT AND CHAIN;  -- TBLOCK_SUBCOMMIT
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 SHOW transaction_isolation;
- transaction_isolation 
------------------------
- repeatable read
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SHOW transaction_read_only;
- transaction_read_only 
------------------------
- off
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SHOW transaction_deferrable;
- transaction_deferrable 
-------------------------
- on
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 COMMIT;
 ROLLBACK;
 -- different mix of options just for fun
@@ -586,17 +560,14 @@
 COMMIT;
 -- not allowed outside a transaction block
 COMMIT AUTONOMOUS AND CHAIN;  -- error
-ERROR:  COMMIT AND CHAIN can only be used in transaction blocks
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 ROLLBACK AUTONOMOUS AND CHAIN;  -- error
 ERROR:  ROLLBACK AND CHAIN can only be used in transaction blocks
 SELECT * FROM abc ORDER BY 1;
  a 
 ---
- 1
- 2
- 4
  5
-(4 rows)
+(1 row)
 
 RESET default_transaction_read_only;
 DROP TABLE abc;
diff ../../../src/test/regress/expected/rules.out ../tmp_check/regress_outdir/results/rules.out
--- ../../../src/test/regress/expected/rules.out	CENSORED
+++ ../tmp_check/regress_outdir/results/rules.out	CENSORED
@@ -1285,6 +1285,15 @@
 SELECT viewname, definition FROM pg_views
 WHERE schemaname IN ('pg_catalog', 'public')
 ORDER BY viewname;
+_pg_prepared_xacts| SELECT p.transaction,
+    p.gid,
+    p.prepared,
+    u.rolname AS owner,
+    d.datname AS database,
+    p.state3pc
+   FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid, state3pc)
+     LEFT JOIN pg_authid u ON ((p.ownerid = u.oid)))
+     LEFT JOIN pg_database d ON ((p.dbid = d.oid)));
 iexit| SELECT ih.name,
     ih.thepath,
     interpt_pp(ih.thepath, r.thepath) AS exit
@@ -1465,15 +1474,15 @@
     p.generic_plans,
     p.custom_plans
    FROM pg_prepared_statement() p(name, statement, prepare_time, parameter_types, from_sql, generic_plans, custom_plans);
-pg_prepared_xacts| SELECT p.transaction,
-    p.gid,
-    p.prepared,
-    u.rolname AS owner,
-    d.datname AS database,
-    p.state3pc
-   FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid, state3pc)
-     LEFT JOIN pg_authid u ON ((p.ownerid = u.oid)))
-     LEFT JOIN pg_database d ON ((p.dbid = d.oid)));
+pg_prepared_xacts| SELECT _pg_prepared_xacts.transaction,
+    _pg_prepared_xacts.gid,
+    _pg_prepared_xacts.prepared,
+    _pg_prepared_xacts.owner,
+    _pg_prepared_xacts.database,
+    _pg_prepared_xacts.state3pc
+   FROM _pg_prepared_xacts
+  WHERE (_pg_prepared_xacts.gid !~~ 'MTM-%'::text)
+  ORDER BY ((_pg_prepared_xacts.transaction)::text)::bigint;
 pg_publication_tables| SELECT p.pubname,
     n.nspname AS schemaname,
     c.relname AS tablename
diff ../../../src/test/regress/expected/publication.out ../tmp_check/regress_outdir/results/publication.out
--- ../../../src/test/regress/expected/publication.out	CENSORED
+++ ../tmp_check/regress_outdir/results/publication.out	CENSORED
@@ -13,8 +13,9 @@
 SELECT obj_description(p.oid, 'pg_publication') FROM pg_publication p;
  obj_description  
 ------------------
+ 
  test publication
-(1 row)
+(2 rows)
 
 SET client_min_messages = 'ERROR';
 CREATE PUBLICATION testpib_ins_trunct WITH (publish = insert);
@@ -31,18 +32,20 @@
                                               List of publications
         Name        |          Owner           | All tables | Inserts | Updates | Deletes | Truncates | Via root 
 --------------------+--------------------------+------------+---------+---------+---------+-----------+----------
+ multimaster        | miker                    | f          | t       | f       | f       | t         | f
  testpib_ins_trunct | regress_publication_user | f          | t       | f       | f       | f         | f
  testpub_default    | regress_publication_user | f          | f       | t       | f       | f         | f
-(2 rows)
+(3 rows)
 
 ALTER PUBLICATION testpub_default SET (publish = 'insert, update, delete');
 \dRp
                                               List of publications
         Name        |          Owner           | All tables | Inserts | Updates | Deletes | Truncates | Via root 
 --------------------+--------------------------+------------+---------+---------+---------+-----------+----------
+ multimaster        | miker                    | f          | t       | f       | f       | t         | f
  testpib_ins_trunct | regress_publication_user | f          | t       | f       | f       | f         | f
  testpub_default    | regress_publication_user | f          | t       | t       | t       | f         | f
-(2 rows)
+(3 rows)
 
 --- adding tables
 CREATE SCHEMA pub_test;
diff ../../../src/test/regress/expected/subscription.out ../tmp_check/regress_outdir/results/subscription.out
--- ../../../src/test/regress/expected/subscription.out	CENSORED
+++ ../tmp_check/regress_outdir/results/subscription.out	CENSORED
@@ -34,8 +34,10 @@
 SELECT obj_description(s.oid, 'pg_subscription') FROM pg_subscription s;
   obj_description  
 -------------------
+ 
+ 
  test subscription
-(1 row)
+(3 rows)
 
 -- fail - name already exists
 CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false);
@@ -76,11 +78,13 @@
 ERROR:  invalid connection string syntax: missing "=" after "foobar" in connection info string
 
 \dRs+
-                                                            List of subscriptions
-      Name       |           Owner           | Enabled | Publication | Binary | Streaming | Synchronous commit |          Conninfo           
------------------+---------------------------+---------+-------------+--------+-----------+--------------------+-----------------------------
- regress_testsub | regress_subscription_user | f       | {testpub}   | f      | f         | off                | dbname=regress_doesnotexist
-(1 row)
+                                                                      List of subscriptions
+      Name       |           Owner           | Enabled |  Publication  | Binary | Streaming | Synchronous commit |                   Conninfo                    
+-----------------+---------------------------+---------+---------------+--------+-----------+--------------------+-----------------------------------------------
+ regress_testsub | regress_subscription_user | f       | {testpub}     | f      | f         | off                | dbname=regress_doesnotexist
+(3 rows)
 
 ALTER SUBSCRIPTION regress_testsub SET PUBLICATION testpub2, testpub3 WITH (refresh = false);
 ALTER SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist2';
@@ -94,11 +98,13 @@
 ALTER SUBSCRIPTION regress_testsub SET (create_slot = false);
 ERROR:  unrecognized subscription parameter: "create_slot"
 \dRs+
-                                                                List of subscriptions
-      Name       |           Owner           | Enabled |     Publication     | Binary | Streaming | Synchronous commit |           Conninfo           
------------------+---------------------------+---------+---------------------+--------+-----------+--------------------+------------------------------
+                                                                         List of subscriptions
+      Name       |           Owner           | Enabled |     Publication     | Binary | Streaming | Synchronous commit |                   Conninfo                    
+-----------------+---------------------------+---------+---------------------+--------+-----------+--------------------+-----------------------------------------------
  regress_testsub | regress_subscription_user | f       | {testpub2,testpub3} | f      | f         | off                | dbname=regress_doesnotexist2
-(1 row)
+(3 rows)
 
 BEGIN;
 ALTER SUBSCRIPTION regress_testsub ENABLE;
@@ -106,16 +112,20 @@
                             List of subscriptions
       Name       |           Owner           | Enabled |     Publication     
 -----------------+---------------------------+---------+---------------------
  regress_testsub | regress_subscription_user | t       | {testpub2,testpub3}
-(1 row)
+(3 rows)
 
 ALTER SUBSCRIPTION regress_testsub DISABLE;
 \dRs
                             List of subscriptions
       Name       |           Owner           | Enabled |     Publication     
 -----------------+---------------------------+---------+---------------------
  regress_testsub | regress_subscription_user | f       | {testpub2,testpub3}
-(1 row)
+(3 rows)
 
 COMMIT;
 -- fail - must be owner of subscription
@@ -129,11 +139,13 @@
 ERROR:  invalid value for parameter "synchronous_commit": "foobar"
 HINT:  Available values: local, remote_write, remote_apply, on, off.
 \dRs+
-                                                                  List of subscriptions
-        Name         |           Owner           | Enabled |     Publication     | Binary | Streaming | Synchronous commit |           Conninfo           
----------------------+---------------------------+---------+---------------------+--------+-----------+--------------------+------------------------------
+                                                                           List of subscriptions
+        Name         |           Owner           | Enabled |     Publication     | Binary | Streaming | Synchronous commit |                   Conninfo                    
+---------------------+---------------------------+---------+---------------------+--------+-----------+--------------------+-----------------------------------------------
  regress_testsub_foo | regress_subscription_user | f       | {testpub2,testpub3} | f      | f         | local              | dbname=regress_doesnotexist2
-(1 row)
+(3 rows)
 
 -- rename back to keep the rest simple
 ALTER SUBSCRIPTION regress_testsub_foo RENAME TO regress_testsub;
@@ -165,20 +177,24 @@
 CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, binary = true);
 WARNING:  tables were not subscribed, you will have to run ALTER SUBSCRIPTION ... REFRESH PUBLICATION to subscribe the tables
 \dRs+
-                                                            List of subscriptions
-      Name       |           Owner           | Enabled | Publication | Binary | Streaming | Synchronous commit |          Conninfo           
------------------+---------------------------+---------+-------------+--------+-----------+--------------------+-----------------------------
- regress_testsub | regress_subscription_user | f       | {testpub}   | t      | f         | off                | dbname=regress_doesnotexist
-(1 row)
+                                                                      List of subscriptions
+      Name       |           Owner           | Enabled |  Publication  | Binary | Streaming | Synchronous commit |                   Conninfo                    
+-----------------+---------------------------+---------+---------------+--------+-----------+--------------------+-----------------------------------------------
+ regress_testsub | regress_subscription_user | f       | {testpub}     | t      | f         | off                | dbname=regress_doesnotexist
+(3 rows)
 
 ALTER SUBSCRIPTION regress_testsub SET (binary = false);
 ALTER SUBSCRIPTION regress_testsub SET (slot_name = NONE);
 \dRs+
-                                                            List of subscriptions
-      Name       |           Owner           | Enabled | Publication | Binary | Streaming | Synchronous commit |          Conninfo           
------------------+---------------------------+---------+-------------+--------+-----------+--------------------+-----------------------------
- regress_testsub | regress_subscription_user | f       | {testpub}   | f      | f         | off                | dbname=regress_doesnotexist
-(1 row)
+                                                                      List of subscriptions
+      Name       |           Owner           | Enabled |  Publication  | Binary | Streaming | Synchronous commit |                   Conninfo                    
+-----------------+---------------------------+---------+---------------+--------+-----------+--------------------+-----------------------------------------------
+ regress_testsub | regress_subscription_user | f       | {testpub}     | f      | f         | off                | dbname=regress_doesnotexist
+(3 rows)
 
 DROP SUBSCRIPTION regress_testsub;
 -- fail - streaming must be boolean
@@ -188,20 +204,24 @@
 CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, streaming = true);
 WARNING:  tables were not subscribed, you will have to run ALTER SUBSCRIPTION ... REFRESH PUBLICATION to subscribe the tables
 \dRs+
-                                                            List of subscriptions
-      Name       |           Owner           | Enabled | Publication | Binary | Streaming | Synchronous commit |          Conninfo           
------------------+---------------------------+---------+-------------+--------+-----------+--------------------+-----------------------------
- regress_testsub | regress_subscription_user | f       | {testpub}   | f      | t         | off                | dbname=regress_doesnotexist
-(1 row)
+                                                                      List of subscriptions
+      Name       |           Owner           | Enabled |  Publication  | Binary | Streaming | Synchronous commit |                   Conninfo                    
+-----------------+---------------------------+---------+---------------+--------+-----------+--------------------+-----------------------------------------------
+ regress_testsub | regress_subscription_user | f       | {testpub}     | f      | t         | off                | dbname=regress_doesnotexist
+(3 rows)
 
 ALTER SUBSCRIPTION regress_testsub SET (streaming = false);
 ALTER SUBSCRIPTION regress_testsub SET (slot_name = NONE);
 \dRs+
-                                                            List of subscriptions
-      Name       |           Owner           | Enabled | Publication | Binary | Streaming | Synchronous commit |          Conninfo           
------------------+---------------------------+---------+-------------+--------+-----------+--------------------+-----------------------------
- regress_testsub | regress_subscription_user | f       | {testpub}   | f      | f         | off                | dbname=regress_doesnotexist
-(1 row)
+                                                                      List of subscriptions
+      Name       |           Owner           | Enabled |  Publication  | Binary | Streaming | Synchronous commit |                   Conninfo                    
+-----------------+---------------------------+---------+---------------+--------+-----------+--------------------+-----------------------------------------------
+ regress_testsub | regress_subscription_user | f       | {testpub}     | f      | f         | off                | dbname=regress_doesnotexist
+(3 rows)
 
 -- fail - publication already exists
 ALTER SUBSCRIPTION regress_testsub ADD PUBLICATION testpub WITH (refresh = false);
@@ -215,11 +235,13 @@
 ALTER SUBSCRIPTION regress_testsub ADD PUBLICATION testpub1, testpub2 WITH (refresh = false);
 ERROR:  publication "testpub1" is already in subscription "regress_testsub"
 \dRs+
-                                                                    List of subscriptions
-      Name       |           Owner           | Enabled |         Publication         | Binary | Streaming | Synchronous commit |          Conninfo           
------------------+---------------------------+---------+-----------------------------+--------+-----------+--------------------+-----------------------------
+                                                                             List of subscriptions
+      Name       |           Owner           | Enabled |         Publication         | Binary | Streaming | Synchronous commit |                   Conninfo                    
+-----------------+---------------------------+---------+-----------------------------+--------+-----------+--------------------+-----------------------------------------------
  regress_testsub | regress_subscription_user | f       | {testpub,testpub1,testpub2} | f      | f         | off                | dbname=regress_doesnotexist
-(1 row)
+(3 rows)
 
 -- fail - publication used more then once
 ALTER SUBSCRIPTION regress_testsub DROP PUBLICATION testpub1, testpub1 WITH (refresh = false);
@@ -233,11 +255,13 @@
 -- ok - delete publications
 ALTER SUBSCRIPTION regress_testsub DROP PUBLICATION testpub1, testpub2 WITH (refresh = false);
 \dRs+
-                                                            List of subscriptions
-      Name       |           Owner           | Enabled | Publication | Binary | Streaming | Synchronous commit |          Conninfo           
------------------+---------------------------+---------+-------------+--------+-----------+--------------------+-----------------------------
- regress_testsub | regress_subscription_user | f       | {testpub}   | f      | f         | off                | dbname=regress_doesnotexist
-(1 row)
+                                                                      List of subscriptions
+      Name       |           Owner           | Enabled |  Publication  | Binary | Streaming | Synchronous commit |                   Conninfo                    
+-----------------+---------------------------+---------+---------------+--------+-----------+--------------------+-----------------------------------------------
+ regress_testsub | regress_subscription_user | f       | {testpub}     | f      | f         | off                | dbname=regress_doesnotexist
+(3 rows)
 
 DROP SUBSCRIPTION regress_testsub;
 CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION mypub
diff ../../../src/test/regress/expected/prepare.out ../tmp_check/regress_outdir/results/prepare.out
--- ../../../src/test/regress/expected/prepare.out	CENSORED
+++ ../tmp_check/regress_outdir/results/prepare.out	CENSORED
@@ -126,34 +126,18 @@
 	SELECT * FROM tenk1 WHERE unique1 = $1 OR stringu1 = $2
 	ORDER BY unique1;
 CREATE TEMPORARY TABLE q5_prep_results AS EXECUTE q5(200, 'DTAAAA');
+ERROR:  [MTM] failed to prepare transaction at peer node
 SELECT * FROM q5_prep_results;
- unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
----------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
-     200 |    9441 |   0 |    0 |   0 |      0 |       0 |      200 |         200 |       200 |      200 |   0 |    1 | SHAAAA   | DZNAAA   | HHHHxx
-     497 |    9092 |   1 |    1 |   7 |     17 |      97 |      497 |         497 |       497 |      497 | 194 |  195 | DTAAAA   | SLNAAA   | AAAAxx
-    1173 |    6699 |   1 |    1 |   3 |     13 |      73 |      173 |        1173 |      1173 |     1173 | 146 |  147 | DTAAAA   | RXJAAA   | VVVVxx
-    1849 |    8143 |   1 |    1 |   9 |      9 |      49 |      849 |        1849 |      1849 |     1849 |  98 |   99 | DTAAAA   | FBMAAA   | VVVVxx
-    2525 |      64 |   1 |    1 |   5 |      5 |      25 |      525 |         525 |      2525 |     2525 |  50 |   51 | DTAAAA   | MCAAAA   | AAAAxx
-    3201 |    7309 |   1 |    1 |   1 |      1 |       1 |      201 |        1201 |      3201 |     3201 |   2 |    3 | DTAAAA   | DVKAAA   | HHHHxx
-    3877 |    4060 |   1 |    1 |   7 |     17 |      77 |      877 |        1877 |      3877 |     3877 | 154 |  155 | DTAAAA   | EAGAAA   | AAAAxx
-    4553 |    4113 |   1 |    1 |   3 |     13 |      53 |      553 |         553 |      4553 |     4553 | 106 |  107 | DTAAAA   | FCGAAA   | HHHHxx
-    5229 |    6407 |   1 |    1 |   9 |      9 |      29 |      229 |        1229 |       229 |     5229 |  58 |   59 | DTAAAA   | LMJAAA   | VVVVxx
-    5905 |    9537 |   1 |    1 |   5 |      5 |       5 |      905 |        1905 |       905 |     5905 |  10 |   11 | DTAAAA   | VCOAAA   | HHHHxx
-    6581 |    4686 |   1 |    1 |   1 |      1 |      81 |      581 |         581 |      1581 |     6581 | 162 |  163 | DTAAAA   | GYGAAA   | OOOOxx
-    7257 |    1895 |   1 |    1 |   7 |     17 |      57 |      257 |        1257 |      2257 |     7257 | 114 |  115 | DTAAAA   | XUCAAA   | VVVVxx
-    7933 |    4514 |   1 |    1 |   3 |     13 |      33 |      933 |        1933 |      2933 |     7933 |  66 |   67 | DTAAAA   | QRGAAA   | OOOOxx
-    8609 |    5918 |   1 |    1 |   9 |      9 |       9 |      609 |         609 |      3609 |     8609 |  18 |   19 | DTAAAA   | QTIAAA   | OOOOxx
-    9285 |    8469 |   1 |    1 |   5 |      5 |      85 |      285 |        1285 |      4285 |     9285 | 170 |  171 | DTAAAA   | TNMAAA   | HHHHxx
-    9961 |    2058 |   1 |    1 |   1 |      1 |      61 |      961 |        1961 |      4961 |     9961 | 122 |  123 | DTAAAA   | EBDAAA   | OOOOxx
-(16 rows)
-
+ERROR:  relation "q5_prep_results" does not exist
+LINE 1: SELECT * FROM q5_prep_results;
+                      ^
 CREATE TEMPORARY TABLE q5_prep_nodata AS EXECUTE q5(200, 'DTAAAA')
     WITH NO DATA;
+ERROR:  [MTM] failed to prepare transaction at peer node
 SELECT * FROM q5_prep_nodata;
- unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
----------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
-(0 rows)
-
+ERROR:  relation "q5_prep_nodata" does not exist
+LINE 1: SELECT * FROM q5_prep_nodata;
+                      ^
 -- unknown or unspecified parameter types: should succeed
 PREPARE q6 AS
     SELECT * FROM tenk1 WHERE unique1 = $1 AND stringu1 = $2;
diff ../../../src/test/regress/expected/indexing.out ../tmp_check/regress_outdir/results/indexing.out
--- ../../../src/test/regress/expected/indexing.out	CENSORED
+++ ../tmp_check/regress_outdir/results/indexing.out	CENSORED
@@ -54,7 +54,7 @@
 create table idxpart (a int, b int, c text) partition by range (a);
 create table idxpart1 partition of idxpart for values from (0) to (10);
 create index concurrently on idxpart (a);
-ERROR:  cannot create index on partitioned table "idxpart" concurrently
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 drop table idxpart;
 -- Verify bugfix with query on indexed partitioned table with no partitions
 -- https://postgr.es/m/20180124162006.pmapfiznhgngwtjf@alvherre.pgsql
@@ -175,7 +175,7 @@
 ERROR:  cannot drop index idxpart1_a_idx because index idxpart_a_idx requires it
 HINT:  You can drop index idxpart_a_idx instead.
 drop index concurrently idxpart_a_idx;	-- unsupported
-ERROR:  cannot drop partitioned index "idxpart_a_idx" concurrently
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 drop index idxpart_a_idx;	-- both indexes go away
 select relname, relkind from pg_class
   where relname like 'idxpart%' order by relname;
@@ -206,12 +206,14 @@
 HINT:  You can drop index idxpart_temp_a_idx instead.
 -- non-concurrent drop is enforced here, so it is a valid case.
 drop index concurrently idxpart_temp_a_idx;
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 select relname, relkind from pg_class
   where relname like 'idxpart_temp%' order by relname;
-   relname    | relkind 
---------------+---------
- idxpart_temp | p
-(1 row)
+      relname       | relkind 
+--------------------+---------
+ idxpart_temp       | p
+ idxpart_temp_a_idx | I
+(2 rows)
 
 drop table idxpart_temp;
 -- ALTER INDEX .. ATTACH, error cases
