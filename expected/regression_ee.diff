diff ../../../src/test/regress/expected/create_table.out ../tmp_check/regress_outdir/results/create_table.out
--- ../../../src/test/regress/expected/create_table.out	CENSORED
+++ ../tmp_check/regress_outdir/results/create_table.out	CENSORED
@@ -263,17 +263,17 @@
 DROP TABLE as_select1;
 PREPARE select1 AS SELECT 1 as a;
 CREATE TABLE as_select1 AS EXECUTE select1;
+ERROR:  [MTM] failed to prepare transaction at peer node
 CREATE TABLE as_select1 AS EXECUTE select1;
-ERROR:  relation "as_select1" already exists
+ERROR:  [MTM] failed to prepare transaction at peer node
 SELECT * FROM as_select1;
- a 
----
- 1
-(1 row)
-
+ERROR:  relation "as_select1" does not exist
+LINE 1: SELECT * FROM as_select1;
+                      ^
 CREATE TABLE IF NOT EXISTS as_select1 AS EXECUTE select1;
-NOTICE:  relation "as_select1" already exists, skipping
+ERROR:  [MTM] failed to prepare transaction at peer node
 DROP TABLE as_select1;
+ERROR:  table "as_select1" does not exist
 DEALLOCATE select1;
 -- create an extra wide table to test for issues related to that
 -- (temporarily hide query, to avoid the long CREATE TABLE stmt)
diff ../../../src/test/regress/expected/create_index.out ../tmp_check/regress_outdir/results/create_index.out
--- ../../../src/test/regress/expected/create_index.out	CENSORED
+++ ../tmp_check/regress_outdir/results/create_index.out	CENSORED
@@ -1367,31 +1367,33 @@
 CREATE TABLE concur_heap (f1 text, f2 text);
 -- empty table
 CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
-NOTICE:  relation "concur_index1" already exists, skipping
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 INSERT INTO concur_heap VALUES  ('a','b');
 INSERT INTO concur_heap VALUES  ('b','b');
 -- unique index
 CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
-NOTICE:  relation "concur_index2" already exists, skipping
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 -- check if constraint is set up properly to be enforced
 INSERT INTO concur_heap VALUES ('b','x');
-ERROR:  duplicate key value violates unique constraint "concur_index2"
-DETAIL:  Key (f1)=(b) already exists.
 -- check if constraint is enforced properly at build time
 CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
-ERROR:  could not create unique index "concur_index3"
-DETAIL:  Key (f2)=(b) is duplicated.
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 -- test that expression indexes and partial indexes work concurrently
 CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 -- here we also check that you can default the index name
 CREATE INDEX CONCURRENTLY on concur_heap((f2||f1));
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 -- You can't do a concurrent index build in a transaction
 BEGIN;
 CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
-ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 COMMIT;
 -- But you can do a regular index build in a transaction
 BEGIN;
@@ -1400,8 +1402,6 @@
 -- Failed builds are left invalid by VACUUM FULL, fixed by REINDEX
 VACUUM FULL concur_heap;
 REINDEX TABLE concur_heap;
-ERROR:  could not create unique index "concur_index3"
-DETAIL:  Key (f2)=(b) is duplicated.
 DELETE FROM concur_heap WHERE f1 = 'b';
 VACUUM FULL concur_heap;
 \d concur_heap
@@ -1411,12 +1411,6 @@
  f1     | text |           |          | 
  f2     | text |           |          | 
 Indexes:
-    "concur_heap_expr_idx" btree ((f2 || f1))
-    "concur_index1" btree (f2, f1)
-    "concur_index2" UNIQUE, btree (f1)
-    "concur_index3" UNIQUE, btree (f2) INVALID
-    "concur_index4" btree (f2) WHERE f1 = 'a'::text
-    "concur_index5" btree (f2) WHERE f1 = 'x'::text
     "std_index" btree (f2)
 
 REINDEX TABLE concur_heap;
@@ -1427,12 +1421,6 @@
  f1     | text |           |          | 
  f2     | text |           |          | 
 Indexes:
-    "concur_heap_expr_idx" btree ((f2 || f1))
-    "concur_index1" btree (f2, f1)
-    "concur_index2" UNIQUE, btree (f1)
-    "concur_index3" UNIQUE, btree (f2)
-    "concur_index4" btree (f2) WHERE f1 = 'a'::text
-    "concur_index5" btree (f2) WHERE f1 = 'x'::text
     "std_index" btree (f2)
 
 -- Temporary tables with concurrent builds and on-commit actions
@@ -1442,7 +1430,9 @@
   ON COMMIT PRESERVE ROWS;
 INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
 CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 DROP INDEX CONCURRENTLY concur_temp_ind;
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 DROP TABLE concur_temp;
 -- ON COMMIT DROP
 BEGIN;
@@ -1451,34 +1441,42 @@
 INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
 -- Fails when running in a transaction.
 CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
-ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 COMMIT;
 -- ON COMMIT DELETE ROWS
 CREATE TEMP TABLE concur_temp (f1 int, f2 text)
   ON COMMIT DELETE ROWS;
 INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
 CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 DROP INDEX CONCURRENTLY concur_temp_ind;
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 DROP TABLE concur_temp;
 --
 -- Try some concurrent index drops
 --
 DROP INDEX CONCURRENTLY "concur_index2";				-- works
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 DROP INDEX CONCURRENTLY IF EXISTS "concur_index2";		-- notice
-NOTICE:  index "concur_index2" does not exist, skipping
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 -- failures
 DROP INDEX CONCURRENTLY "concur_index2", "concur_index3";
-ERROR:  DROP INDEX CONCURRENTLY does not support dropping multiple objects
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 BEGIN;
 DROP INDEX CONCURRENTLY "concur_index5";
-ERROR:  DROP INDEX CONCURRENTLY cannot run inside a transaction block
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 ROLLBACK;
 -- successes
 DROP INDEX CONCURRENTLY IF EXISTS "concur_index3";
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 DROP INDEX CONCURRENTLY "concur_index4";
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 DROP INDEX CONCURRENTLY "concur_index5";
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 DROP INDEX CONCURRENTLY "concur_index1";
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 DROP INDEX CONCURRENTLY "concur_heap_expr_idx";
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 \d concur_heap
            Table "public.concur_heap"
  Column | Type | Collation | Nullable | Default 
@@ -2416,46 +2414,38 @@
 INSERT INTO concur_reindex_tab4 VALUES (1), (1), (2);
 -- This trick creates an invalid index.
 CREATE UNIQUE INDEX CONCURRENTLY concur_reindex_ind5 ON concur_reindex_tab4 (c1);
-ERROR:  could not create unique index "concur_reindex_ind5"
-DETAIL:  Key (c1)=(1) is duplicated.
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 -- Reindexing concurrently this index fails with the same failure.
 -- The extra index created is itself invalid, and can be dropped.
 REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
-ERROR:  could not create unique index "concur_reindex_ind5_ccnew"
-DETAIL:  Key (c1)=(1) is duplicated.
+ERROR:  relation "concur_reindex_ind5" does not exist
 \d concur_reindex_tab4
         Table "public.concur_reindex_tab4"
  Column |  Type   | Collation | Nullable | Default 
 --------+---------+-----------+----------+---------
  c1     | integer |           |          | 
-Indexes:
-    "concur_reindex_ind5" UNIQUE, btree (c1) INVALID
-    "concur_reindex_ind5_ccnew" UNIQUE, btree (c1) INVALID
 
 DROP INDEX concur_reindex_ind5_ccnew;
+ERROR:  index "concur_reindex_ind5_ccnew" does not exist
 -- This makes the previous failure go away, so the index can become valid.
 DELETE FROM concur_reindex_tab4 WHERE c1 = 1;
 -- The invalid index is not processed when running REINDEX TABLE.
 REINDEX TABLE CONCURRENTLY concur_reindex_tab4;
-WARNING:  cannot reindex invalid index "public.concur_reindex_ind5" concurrently, skipping
 NOTICE:  table "concur_reindex_tab4" has no indexes that can be reindexed concurrently
 \d concur_reindex_tab4
         Table "public.concur_reindex_tab4"
  Column |  Type   | Collation | Nullable | Default 
 --------+---------+-----------+----------+---------
  c1     | integer |           |          | 
-Indexes:
-    "concur_reindex_ind5" UNIQUE, btree (c1) INVALID
 
 -- But it is fixed with REINDEX INDEX.
 REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
+ERROR:  relation "concur_reindex_ind5" does not exist
 \d concur_reindex_tab4
         Table "public.concur_reindex_tab4"
  Column |  Type   | Collation | Nullable | Default 
 --------+---------+-----------+----------+---------
  c1     | integer |           |          | 
-Indexes:
-    "concur_reindex_ind5" UNIQUE, btree (c1)
 
 DROP TABLE concur_reindex_tab4;
 -- Check handling of indexes with expressions and predicates.  The
diff ../../../src/test/regress/expected/index_including.out ../tmp_check/regress_outdir/results/index_including.out
--- ../../../src/test/regress/expected/index_including.out	CENSORED
+++ ../tmp_check/regress_outdir/results/index_including.out	CENSORED
@@ -310,12 +310,12 @@
 CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box, UNIQUE(c1, c2) INCLUDE(c3,c4));
 INSERT INTO tbl SELECT x, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,1000) AS x;
 CREATE UNIQUE INDEX CONCURRENTLY on tbl (c1, c2) INCLUDE (c3, c4);
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl' ORDER BY indexname;
                                           indexdef                                           
 ---------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX tbl_c1_c2_c3_c4_idx ON public.tbl USING btree (c1, c2) INCLUDE (c3, c4)
  CREATE UNIQUE INDEX tbl_c1_c2_c3_c4_key ON public.tbl USING btree (c1, c2) INCLUDE (c3, c4)
-(2 rows)
+(1 row)
 
 DROP TABLE tbl;
 /*
diff ../../../src/test/regress/expected/index_including_gist.out ../tmp_check/regress_outdir/results/index_including_gist.out
--- ../../../src/test/regress/expected/index_including_gist.out	CENSORED
+++ ../tmp_check/regress_outdir/results/index_including_gist.out	CENSORED
@@ -74,11 +74,11 @@
 CREATE TABLE tbl_gist (c1 int, c2 int, c3 int, c4 box);
 INSERT INTO tbl_gist SELECT x, 2*x, 3*x, box(point(x,x+1),point(2*x,2*x+1)) FROM generate_series(1,10) AS x;
 CREATE INDEX CONCURRENTLY tbl_gist_idx ON tbl_gist using gist (c4) INCLUDE (c1,c2,c3);
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl_gist' ORDER BY indexname;
-                                     indexdef                                      
------------------------------------------------------------------------------------
- CREATE INDEX tbl_gist_idx ON public.tbl_gist USING gist (c4) INCLUDE (c1, c2, c3)
-(1 row)
+ indexdef 
+----------
+(0 rows)
 
 DROP TABLE tbl_gist;
 /*
diff ../../../src/test/regress/expected/sanity_check.out ../tmp_check/regress_outdir/results/sanity_check.out
--- ../../../src/test/regress/expected/sanity_check.out	CENSORED
+++ ../tmp_check/regress_outdir/results/sanity_check.out	CENSORED
@@ -11,6 +11,8 @@
    FROM pg_class c LEFT JOIN pg_namespace n ON n.oid = relnamespace
    WHERE relkind IN ('r', 'p') AND (nspname ~ '^pg_temp_') IS NOT TRUE
    ORDER BY relname;
+_pg_publication|t
+_pg_subscription|t
 a|f
 a_star|f
 aggtest|f
@@ -32,6 +34,8 @@
 check_tbl|f
 circle_tbl|t
 city|f
+cluster_nodes|t
+config|t
 copy_tbl|f
 d|f
 d_star|f
@@ -67,6 +71,7 @@
 jtbl|t
 kd_point_tbl|t
 line_tbl|f
+local_tables|t
 log_table|f
 lseg_tbl|f
 main_table|f
@@ -83,6 +88,7 @@
 mlparted_defd|f
 money_data|f
 mytable|t
+nodes_init_done|t
 num_data|f
 num_exp_add|t
 num_exp_div|t
@@ -140,7 +146,6 @@
 pg_policy|t
 pg_proc|t
 pg_profile|t
-pg_publication|t
 pg_publication_rel|t
 pg_range|t
 pg_replication_origin|t
@@ -154,7 +159,6 @@
 pg_statistic|t
 pg_statistic_ext|t
 pg_statistic_ext_data|t
-pg_subscription|t
 pg_subscription_rel|t
 pg_tablespace|t
 pg_transform|t
@@ -185,6 +189,7 @@
 sql_sizing|f
 stud_emp|f
 student|f
+syncpoints|t
 tableam_parted_a_heap2|f
 tableam_parted_b_heap2|f
 tableam_parted_c_heap2|f
diff ../../../src/test/regress/expected/transactions.out ../tmp_check/regress_outdir/results/transactions.out
--- ../../../src/test/regress/expected/transactions.out	CENSORED
+++ ../tmp_check/regress_outdir/results/transactions.out	CENSORED
@@ -685,50 +685,38 @@
 INSERT INTO abc VALUES (1);
 INSERT INTO abc VALUES (2);
 COMMIT AND CHAIN;  -- TBLOCK_END
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 SHOW transaction_isolation;
- transaction_isolation 
------------------------
- repeatable read
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SHOW transaction_read_only;
- transaction_read_only 
------------------------
- off
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SHOW transaction_deferrable;
- transaction_deferrable 
-------------------------
- on
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 INSERT INTO abc VALUES ('error');
-ERROR:  invalid input syntax for type integer: "error"
-LINE 1: INSERT INTO abc VALUES ('error');
-                                ^
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 INSERT INTO abc VALUES (3);  -- check it's really aborted
 ERROR:  current transaction is aborted, commands ignored until end of transaction block
 COMMIT AND CHAIN;  -- TBLOCK_ABORT_END
 SHOW transaction_isolation;
  transaction_isolation 
 -----------------------
- repeatable read
+ read committed
 (1 row)
 
 SHOW transaction_read_only;
  transaction_read_only 
 -----------------------
- off
+ on
 (1 row)
 
 SHOW transaction_deferrable;
  transaction_deferrable 
 ------------------------
- on
+ off
 (1 row)
 
 INSERT INTO abc VALUES (4);
+ERROR:  cannot execute INSERT in a read-only transaction
 COMMIT;
 START TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ WRITE, DEFERRABLE;
 SHOW transaction_isolation;
@@ -841,17 +829,14 @@
 ROLLBACK;
 -- not allowed outside a transaction block
 COMMIT AND CHAIN;  -- error
-ERROR:  COMMIT AND CHAIN can only be used in transaction blocks
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 ROLLBACK AND CHAIN;  -- error
 ERROR:  ROLLBACK AND CHAIN can only be used in transaction blocks
 SELECT * FROM abc ORDER BY 1;
  a 
 ---
- 1
- 2
- 4
  5
-(4 rows)
+(1 row)
 
 RESET default_transaction_read_only;
 DROP TABLE abc;
@@ -941,7 +926,7 @@
 SELECT 1\; BEGIN\; SAVEPOINT sp\; ROLLBACK TO SAVEPOINT sp\; COMMIT;
 -- Tests for AND CHAIN in implicit transaction blocks
 SET TRANSACTION READ ONLY\; COMMIT AND CHAIN;  -- error
-ERROR:  COMMIT AND CHAIN can only be used in transaction blocks
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 SHOW transaction_read_only;
  transaction_read_only 
 -----------------------
@@ -960,23 +945,20 @@
 -- COMMIT/ROLLBACK + COMMIT/ROLLBACK AND CHAIN
 INSERT INTO abc VALUES (7)\; COMMIT\; INSERT INTO abc VALUES (8)\; COMMIT AND CHAIN;  -- 7 commit, 8 error
 WARNING:  there is no transaction in progress
-ERROR:  COMMIT AND CHAIN can only be used in transaction blocks
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 INSERT INTO abc VALUES (9)\; ROLLBACK\; INSERT INTO abc VALUES (10)\; ROLLBACK AND CHAIN;  -- 9 rollback, 10 error
 WARNING:  there is no transaction in progress
 ERROR:  ROLLBACK AND CHAIN can only be used in transaction blocks
 -- COMMIT/ROLLBACK AND CHAIN + COMMIT/ROLLBACK
 INSERT INTO abc VALUES (11)\; COMMIT AND CHAIN\; INSERT INTO abc VALUES (12)\; COMMIT;  -- 11 error, 12 not reached
-ERROR:  COMMIT AND CHAIN can only be used in transaction blocks
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 INSERT INTO abc VALUES (13)\; ROLLBACK AND CHAIN\; INSERT INTO abc VALUES (14)\; ROLLBACK;  -- 13 error, 14 not reached
 ERROR:  ROLLBACK AND CHAIN can only be used in transaction blocks
 -- START TRANSACTION + COMMIT/ROLLBACK AND CHAIN
 START TRANSACTION ISOLATION LEVEL REPEATABLE READ\; INSERT INTO abc VALUES (15)\; COMMIT AND CHAIN;  -- 15 ok
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 SHOW transaction_isolation;  -- transaction is active at this point
- transaction_isolation 
------------------------
- repeatable read
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 COMMIT;
 START TRANSACTION ISOLATION LEVEL REPEATABLE READ\; INSERT INTO abc VALUES (16)\; ROLLBACK AND CHAIN;  -- 16 ok
 SHOW transaction_isolation;  -- transaction is active at this point
@@ -988,7 +970,7 @@
 ROLLBACK;
 -- START TRANSACTION + COMMIT/ROLLBACK + COMMIT/ROLLBACK AND CHAIN
 START TRANSACTION ISOLATION LEVEL REPEATABLE READ\; INSERT INTO abc VALUES (17)\; COMMIT\; INSERT INTO abc VALUES (18)\; COMMIT AND CHAIN;  -- 17 commit, 18 error
-ERROR:  COMMIT AND CHAIN can only be used in transaction blocks
+ERROR:  [MTM] COMMIT AND CHAIN is not supported
 SHOW transaction_isolation;  -- out of transaction block
  transaction_isolation 
 -----------------------
@@ -1007,9 +989,8 @@
  a  
 ----
   7
- 15
  17
-(3 rows)
+(2 rows)
 
 DROP TABLE abc;
 -- Test for successful cleanup of an aborted transaction at session exit.
diff ../../../src/test/regress/expected/brin.out ../tmp_check/regress_outdir/results/brin.out
--- ../../../src/test/regress/expected/brin.out	CENSORED
+++ ../tmp_check/regress_outdir/results/brin.out	CENSORED
@@ -539,7 +539,9 @@
 -- vacuum actually removes the TOAST rows. Creating an index concurrently
 -- is a one way to achieve that, because it does exactly such wait.
 CREATE INDEX CONCURRENTLY brin_test_temp_idx ON brintest_3(a);
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 DROP INDEX brin_test_temp_idx;
+ERROR:  index "brin_test_temp_idx" does not exist
 -- vacuum the table, to discard TOAST data
 VACUUM brintest_3;
 -- retry insert with a different random-looking (but deterministic) value
diff ../../../src/test/regress/expected/rowsecurity.out ../tmp_check/regress_outdir/results/rowsecurity.out
--- ../../../src/test/regress/expected/rowsecurity.out	CENSORED
+++ ../tmp_check/regress_outdir/results/rowsecurity.out	CENSORED
@@ -113,30 +113,7 @@
 (3 rows)
 
 \d document
-        Table "regress_rls_schema.document"
- Column  |  Type   | Collation | Nullable | Default 
----------+---------+-----------+----------+---------
- did     | integer |           | not null | 
- cid     | integer |           |          | 
- dlevel  | integer |           | not null | 
- dauthor | name    |           |          | 
- dtitle  | text    |           |          | 
-Indexes:
-    "document_pkey" PRIMARY KEY, btree (did)
-Foreign-key constraints:
-    "document_cid_fkey" FOREIGN KEY (cid) REFERENCES category(cid)
-Policies:
-    POLICY "p1"
-      USING ((dlevel <= ( SELECT uaccount.seclv
-   FROM uaccount
-  WHERE (uaccount.pguser = CURRENT_USER))))
-    POLICY "p1r" AS RESTRICTIVE
-      TO regress_rls_dave
-      USING ((cid <> 44))
-    POLICY "p2r" AS RESTRICTIVE
-      TO regress_rls_dave
-      USING (((cid <> 44) AND (cid < 50)))
-
+ERROR:  permission denied for view pg_publication
 SELECT * FROM pg_policies WHERE schemaname = 'regress_rls_schema' AND tablename = 'document' ORDER BY policyname;
      schemaname     | tablename | policyname | permissive  |       roles        | cmd |                    qual                    | with_check 
 --------------------+-----------+------------+-------------+--------------------+-----+--------------------------------------------+------------
@@ -938,27 +915,7 @@
 CREATE POLICY pp1r ON part_document AS RESTRICTIVE TO regress_rls_dave
     USING (cid < 55);
 \d+ part_document
-                    Partitioned table "regress_rls_schema.part_document"
- Column  |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
----------+---------+-----------+----------+---------+----------+--------------+-------------
- did     | integer |           |          |         | plain    |              | 
- cid     | integer |           |          |         | plain    |              | 
- dlevel  | integer |           | not null |         | plain    |              | 
- dauthor | name    |           |          |         | plain    |              | 
- dtitle  | text    |           |          |         | extended |              | 
-Partition key: RANGE (cid)
-Policies:
-    POLICY "pp1"
-      USING ((dlevel <= ( SELECT uaccount.seclv
-   FROM uaccount
-  WHERE (uaccount.pguser = CURRENT_USER))))
-    POLICY "pp1r" AS RESTRICTIVE
-      TO regress_rls_dave
-      USING ((cid < 55))
-Partitions: part_document_fiction FOR VALUES FROM (11) TO (12),
-            part_document_nonfiction FOR VALUES FROM (99) TO (100),
-            part_document_satire FOR VALUES FROM (55) TO (56)
-
+ERROR:  permission denied for view pg_publication
 SELECT * FROM pg_policies WHERE schemaname = 'regress_rls_schema' AND tablename like '%part_document%' ORDER BY policyname;
      schemaname     |   tablename   | policyname | permissive  |       roles        | cmd |                    qual                    | with_check 
 --------------------+---------------+------------+-------------+--------------------+-----+--------------------------------------------+------------
diff ../../../src/test/regress/expected/atx.out ../tmp_check/regress_outdir/results/atx.out
--- ../../../src/test/regress/expected/atx.out	CENSORED
+++ ../tmp_check/regress_outdir/results/atx.out	CENSORED
@@ -1147,6 +1147,7 @@
 RESET client_min_messages;
 create database regression_atx_test_database;
 ALTER DATABASE "regression_atx_test_database" SET lc_messages TO 'C';
+ERROR:  [MTM] failed to prepare transaction at peer node
 \c regression_atx_test_database
 create table atx_test as select 1 as id;
 begin;
diff ../../../src/test/regress/expected/atx5.out ../tmp_check/regress_outdir/results/atx5.out
--- ../../../src/test/regress/expected/atx5.out	CENSORED
+++ ../tmp_check/regress_outdir/results/atx5.out	CENSORED
@@ -24,10 +24,7 @@
 NOTICE:  function atx_test_30_one() does not exist, skipping
 NOTICE:  function atx_test_30_one() does not exist, skipping
 NOTICE:  function atx_test_30_one() does not exist, skipping
- x 
----
-(0 rows)
-
+ERROR:  cannot PREPARE a transaction that has exported snapshots
 SET client_min_messages = 'warning';
 DROP FUNCTION IF EXISTS atx_test_30_one();
 DROP FUNCTION IF EXISTS atx_test_30_two();
diff ../../../src/test/regress/expected/rules.out ../tmp_check/regress_outdir/results/rules.out
--- ../../../src/test/regress/expected/rules.out	CENSORED
+++ ../tmp_check/regress_outdir/results/rules.out	CENSORED
@@ -1285,6 +1285,15 @@
 SELECT viewname, definition FROM pg_views
 WHERE schemaname IN ('pg_catalog', 'public')
 ORDER BY viewname;
+_pg_prepared_xacts| SELECT p.transaction,
+    p.gid,
+    p.prepared,
+    u.rolname AS owner,
+    d.datname AS database,
+    p.state3pc
+   FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid, state3pc)
+     LEFT JOIN pg_authid u ON ((p.ownerid = u.oid)))
+     LEFT JOIN pg_database d ON ((p.dbid = d.oid)));
 iexit| SELECT ih.name,
     ih.thepath,
     interpt_pp(ih.thepath, r.thepath) AS exit
@@ -1452,19 +1461,30 @@
     p.parameter_types,
     p.from_sql
    FROM pg_prepared_statement() p(name, statement, prepare_time, parameter_types, from_sql);
-pg_prepared_xacts| SELECT p.transaction,
-    p.gid,
-    p.prepared,
-    u.rolname AS owner,
-    d.datname AS database,
-    p.state3pc
-   FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid, state3pc)
-     LEFT JOIN pg_authid u ON ((p.ownerid = u.oid)))
-     LEFT JOIN pg_database d ON ((p.dbid = d.oid)));
+pg_prepared_xacts| SELECT _pg_prepared_xacts.transaction,
+    _pg_prepared_xacts.gid,
+    _pg_prepared_xacts.prepared,
+    _pg_prepared_xacts.owner,
+    _pg_prepared_xacts.database,
+    _pg_prepared_xacts.state3pc
+   FROM _pg_prepared_xacts
+  WHERE (_pg_prepared_xacts.gid !~~ 'MTM-%'::text)
+  ORDER BY ((_pg_prepared_xacts.transaction)::text)::bigint;
+pg_publication| SELECT _pg_publication.oid,
+    _pg_publication.pubname,
+    _pg_publication.pubowner,
+    _pg_publication.puballtables,
+    _pg_publication.pubinsert,
+    _pg_publication.pubupdate,
+    _pg_publication.pubdelete,
+    _pg_publication.pubtruncate,
+    _pg_publication.pubviaroot
+   FROM _pg_publication
+  WHERE (_pg_publication.pubname <> 'multimaster'::name);
 pg_publication_tables| SELECT p.pubname,
     n.nspname AS schemaname,
     c.relname AS tablename
-   FROM pg_publication p,
+   FROM _pg_publication p,
     LATERAL pg_get_publication_tables((p.pubname)::text) gpt(relid),
     (pg_class c
      JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
@@ -1659,7 +1679,7 @@
     l.provider,
     l.label
    FROM (pg_seclabel l
-     JOIN pg_publication p ON (((l.classoid = p.tableoid) AND (l.objoid = p.oid))))
+     JOIN _pg_publication p ON (((l.classoid = p.tableoid) AND (l.objoid = p.oid))))
   WHERE (l.objsubid = 0)
 UNION ALL
  SELECT l.objoid,
@@ -1671,7 +1691,7 @@
     l.provider,
     l.label
    FROM (pg_shseclabel l
-     JOIN pg_subscription s ON (((l.classoid = s.tableoid) AND (l.objoid = s.oid))))
+     JOIN _pg_subscription s ON (((l.classoid = s.tableoid) AND (l.objoid = s.oid))))
 UNION ALL
  SELECT l.objoid,
     l.classoid,
@@ -2065,7 +2085,7 @@
     st.last_msg_receipt_time,
     st.latest_end_lsn,
     st.latest_end_time
-   FROM (pg_subscription su
+   FROM (_pg_subscription su
      LEFT JOIN pg_stat_get_subscription(NULL::oid) st(subid, relid, pid, received_lsn, last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time) ON ((st.subid = su.oid)));
 pg_stat_sys_indexes| SELECT pg_stat_all_indexes.relid,
     pg_stat_all_indexes.indexrelid,
@@ -2407,6 +2427,17 @@
            FROM (unnest(s.stxkeys) k(k)
              JOIN pg_attribute a ON (((a.attrelid = s.stxrelid) AND (a.attnum = k.k))))
           WHERE (NOT has_column_privilege(c.oid, a.attnum, 'select'::text))))) AND ((c.relrowsecurity = false) OR (NOT row_security_active(c.oid))));
+pg_subscription| SELECT _pg_subscription.oid,
+    _pg_subscription.subdbid,
+    _pg_subscription.subname,
+    _pg_subscription.subowner,
+    _pg_subscription.subenabled,
+    _pg_subscription.subconninfo,
+    _pg_subscription.subslotname,
+    _pg_subscription.subsynccommit,
+    _pg_subscription.subpublications
+   FROM _pg_subscription
+  WHERE (_pg_subscription.subname !~~ 'mtm_sub_%'::text);
 pg_tables| SELECT n.nspname AS schemaname,
     c.relname AS tablename,
     pg_get_userbyid(c.relowner) AS tableowner,
diff ../../../src/test/regress/expected/publication.out ../tmp_check/regress_outdir/results/publication.out
--- ../../../src/test/regress/expected/publication.out	CENSORED
+++ ../tmp_check/regress_outdir/results/publication.out	CENSORED
@@ -11,9 +11,9 @@
 RESET client_min_messages;
 COMMENT ON PUBLICATION testpub_default IS 'test publication';
 SELECT obj_description(p.oid, 'pg_publication') FROM pg_publication p;
- obj_description  
-------------------
- test publication
+ obj_description 
+-----------------
+ 
 (1 row)
 
 SET client_min_messages = 'ERROR';
diff ../../../src/test/regress/expected/subscription.out ../tmp_check/regress_outdir/results/subscription.out
--- ../../../src/test/regress/expected/subscription.out	CENSORED
+++ ../tmp_check/regress_outdir/results/subscription.out	CENSORED
@@ -32,9 +32,9 @@
 WARNING:  tables were not subscribed, you will have to run ALTER SUBSCRIPTION ... REFRESH PUBLICATION to subscribe the tables
 COMMENT ON SUBSCRIPTION regress_testsub IS 'test subscription';
 SELECT obj_description(s.oid, 'pg_subscription') FROM pg_subscription s;
-  obj_description  
--------------------
- test subscription
+ obj_description 
+-----------------
+ 
 (1 row)
 
 -- fail - name already exists
diff ../../../src/test/regress/expected/prepare.out ../tmp_check/regress_outdir/results/prepare.out
--- ../../../src/test/regress/expected/prepare.out	CENSORED
+++ ../tmp_check/regress_outdir/results/prepare.out	CENSORED
@@ -126,34 +126,18 @@
 	SELECT * FROM tenk1 WHERE unique1 = $1 OR stringu1 = $2
 	ORDER BY unique1;
 CREATE TEMPORARY TABLE q5_prep_results AS EXECUTE q5(200, 'DTAAAA');
+ERROR:  [MTM] failed to prepare transaction at peer node
 SELECT * FROM q5_prep_results;
- unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
----------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
-     200 |    9441 |   0 |    0 |   0 |      0 |       0 |      200 |         200 |       200 |      200 |   0 |    1 | SHAAAA   | DZNAAA   | HHHHxx
-     497 |    9092 |   1 |    1 |   7 |     17 |      97 |      497 |         497 |       497 |      497 | 194 |  195 | DTAAAA   | SLNAAA   | AAAAxx
-    1173 |    6699 |   1 |    1 |   3 |     13 |      73 |      173 |        1173 |      1173 |     1173 | 146 |  147 | DTAAAA   | RXJAAA   | VVVVxx
-    1849 |    8143 |   1 |    1 |   9 |      9 |      49 |      849 |        1849 |      1849 |     1849 |  98 |   99 | DTAAAA   | FBMAAA   | VVVVxx
-    2525 |      64 |   1 |    1 |   5 |      5 |      25 |      525 |         525 |      2525 |     2525 |  50 |   51 | DTAAAA   | MCAAAA   | AAAAxx
-    3201 |    7309 |   1 |    1 |   1 |      1 |       1 |      201 |        1201 |      3201 |     3201 |   2 |    3 | DTAAAA   | DVKAAA   | HHHHxx
-    3877 |    4060 |   1 |    1 |   7 |     17 |      77 |      877 |        1877 |      3877 |     3877 | 154 |  155 | DTAAAA   | EAGAAA   | AAAAxx
-    4553 |    4113 |   1 |    1 |   3 |     13 |      53 |      553 |         553 |      4553 |     4553 | 106 |  107 | DTAAAA   | FCGAAA   | HHHHxx
-    5229 |    6407 |   1 |    1 |   9 |      9 |      29 |      229 |        1229 |       229 |     5229 |  58 |   59 | DTAAAA   | LMJAAA   | VVVVxx
-    5905 |    9537 |   1 |    1 |   5 |      5 |       5 |      905 |        1905 |       905 |     5905 |  10 |   11 | DTAAAA   | VCOAAA   | HHHHxx
-    6581 |    4686 |   1 |    1 |   1 |      1 |      81 |      581 |         581 |      1581 |     6581 | 162 |  163 | DTAAAA   | GYGAAA   | OOOOxx
-    7257 |    1895 |   1 |    1 |   7 |     17 |      57 |      257 |        1257 |      2257 |     7257 | 114 |  115 | DTAAAA   | XUCAAA   | VVVVxx
-    7933 |    4514 |   1 |    1 |   3 |     13 |      33 |      933 |        1933 |      2933 |     7933 |  66 |   67 | DTAAAA   | QRGAAA   | OOOOxx
-    8609 |    5918 |   1 |    1 |   9 |      9 |       9 |      609 |         609 |      3609 |     8609 |  18 |   19 | DTAAAA   | QTIAAA   | OOOOxx
-    9285 |    8469 |   1 |    1 |   5 |      5 |      85 |      285 |        1285 |      4285 |     9285 | 170 |  171 | DTAAAA   | TNMAAA   | HHHHxx
-    9961 |    2058 |   1 |    1 |   1 |      1 |      61 |      961 |        1961 |      4961 |     9961 | 122 |  123 | DTAAAA   | EBDAAA   | OOOOxx
-(16 rows)
-
+ERROR:  relation "q5_prep_results" does not exist
+LINE 1: SELECT * FROM q5_prep_results;
+                      ^
 CREATE TEMPORARY TABLE q5_prep_nodata AS EXECUTE q5(200, 'DTAAAA')
     WITH NO DATA;
+ERROR:  [MTM] failed to prepare transaction at peer node
 SELECT * FROM q5_prep_nodata;
- unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
----------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
-(0 rows)
-
+ERROR:  relation "q5_prep_nodata" does not exist
+LINE 1: SELECT * FROM q5_prep_nodata;
+                      ^
 -- unknown or unspecified parameter types: should succeed
 PREPARE q6 AS
     SELECT * FROM tenk1 WHERE unique1 = $1 AND stringu1 = $2;
diff ../../../src/test/regress/expected/indexing.out ../tmp_check/regress_outdir/results/indexing.out
--- ../../../src/test/regress/expected/indexing.out	CENSORED
+++ ../tmp_check/regress_outdir/results/indexing.out	CENSORED
@@ -54,7 +54,7 @@
 create table idxpart (a int, b int, c text) partition by range (a);
 create table idxpart1 partition of idxpart for values from (0) to (10);
 create index concurrently on idxpart (a);
-ERROR:  cannot create index on partitioned table "idxpart" concurrently
+ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
 drop table idxpart;
 -- Verify bugfix with query on indexed partitioned table with no partitions
 -- https://postgr.es/m/20180124162006.pmapfiznhgngwtjf@alvherre.pgsql
@@ -175,7 +175,7 @@
 ERROR:  cannot drop index idxpart1_a_idx because index idxpart_a_idx requires it
 HINT:  You can drop index idxpart_a_idx instead.
 drop index concurrently idxpart_a_idx;	-- unsupported
-ERROR:  cannot drop partitioned index "idxpart_a_idx" concurrently
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 drop index idxpart_a_idx;	-- both indexes go away
 select relname, relkind from pg_class
   where relname like 'idxpart%' order by relname;
@@ -206,12 +206,14 @@
 HINT:  You can drop index idxpart_temp_a_idx instead.
 -- non-concurrent drop is enforced here, so it is a valid case.
 drop index concurrently idxpart_temp_a_idx;
+ERROR:  multimaster doesn't support DROP INDEX CONCURRENTLY
 select relname, relkind from pg_class
   where relname like 'idxpart_temp%' order by relname;
-   relname    | relkind 
---------------+---------
- idxpart_temp | p
-(1 row)
+      relname       | relkind 
+--------------------+---------
+ idxpart_temp       | p
+ idxpart_temp_a_idx | I
+(2 rows)
 
 drop table idxpart_temp;
 -- ALTER INDEX .. ATTACH, error cases
